Ok, ma qui non vedete niente. Allora, l'idea di oggi è letteralmente di giocare assieme con Neuron, perlomeno a un livello molto elementare. Elementare intendo che non vi faccio vedere simulazioni di modelli multicompartimentali con la morfologia complessa importata da esperimenti di ricostruzione 3D. semplicemente perché io non ne sono un grande esperto e seconda cosa perché la base che spero possa risuonare con la vostra esperienza è quella di paragonare questo tipo di simulazioni, Forse con quanto avete potuto magari orecchiare o avete potuto vedere durante il corso dell'anno scorso con me in cui vi ho fatto vedere qualche esempio di codice risolto con Eulero o con altri metodi numerici che vi ho fatto vedere il modello di Hodgkin e Huxley fatto scrivendosi le equazioni e provando a integrare numericamente. Se volete vi rimando o potete, spero, ritrovare il codice, quel sito web e quel repository GitHub in cui ci sono ancora quei notebook, perché vorrei che aveste l'idea di quanto in teoria sia molto più facile usare questo simulatore, un simulatore standard come questo, invece che scriversi il codice di per sé. Non ci vuole un genio a farlo. D'altro canto qui, adesso lo vedremo, la risoluzione numerica delle equazioni e una parte di descrizione del sistema a basso livello vi è preclusa. Mentre lì eravate voi che scrivevate le equazioni, controllavate il metodo numerico, capivate quali erano le variabili di stato, volevate iniettare una corrente, sapevate dove metterlo, per esempio nel right hand side, come si dice, in un'equazione, nell'equazione del bilancio della carica, nella parte destra era la corrente iniettata. Quindi adesso lo vedete è un pochino nascosto, è un pregio quando uno ha un modello molto complicato, ha un modello di rete molto complicata, però ha degli svantaggi che voi non sapete esattamente se le cose stanno funzionando oppure no. un motto che ho fatto mio anni fa è garbage in, garbage out a meno che non ci sia qualche errore di compilazione, errore di sintassi qualcosa da una simulazione esce sempre vedete delle tracce, vedete dei numeri, vedete dei valori come fate a sapere che è autentico? non è così banale farlo in teoria dovrebbe essere un pochino più facile sviluppare un'intuizione quando il codice lo scrivete da zero voi Comunque, questo è un sistema, un simulatore di riferimento che ha avuto origine negli anni Ottanta e infatti è un pochino il risultato di una stratificazione di approcci e tecniche anche molto vecchie, molto antiquate, non dal punto di vista numerico, in cui l'equazione del cavo, che forse ricordate, era un'equazione alle derivate parziali, forse ce l'ho qui, forse no, no, descrivere e risolvere un sistema distribuito, che qui è già stato discretizzato in modo efficace nello spazio e nel tempo, per cui ovviamente il tempo c'è, ma c'è anche lo spazio richiede un'accortezza maggiore non ve ne parlo, comunque come per l'equazione della diffusione, se vi ricordate l'anno scorso vi dicevo che l'equazione del cavo ha la stessa struttura di un'equazione della diffusione o è simile anche all'equazione della propagazione delle onde. Essendo un'equazione delle derivate parziali sia in T tempo che in X spazio, il delta T e il delta X, quindi il passo di discretizzazione temporale e spaziale, non le potete scegliere a caso, devono essere uno in funzione dell'altro, se no avete veramente dei problemi seri di stabilità numerica, nel senso non che il computer esploda, ma la soluzione che ottenete non è la soluzione corretta. Quando la soluzione è corretta la si può sapere, figuratevi quando non c'è una soluzione analitica che uno può paragonare. Questo simulatore neuron è cresciuto particolarmente da questi due personaggi che sono a Yale, all'università di Yale, Michael Hines particolare, che hanno per primi consolidato un algoritmo molto tosto, numerico, accurato per la risoluzione dell'equazione del cavo. visto che in neuron tutto è un cavo, perché i neuroni sono assunti da essere cavi, questo è stato considerato un buon riferimento. Non è l'unico simulatore, è quello che però è sopravvissuto più a lungo. Questo recentemente, quindi è stato scritto in C++, C++ e non tanto così anticamente, questo fino al 2005-2008, aveva per programmarlo, ed è una programmazione ad alto livello, in cui uno scrive uno script che descrive, lo vediamo, non C, D, V, S, D, T uguale, No, scrive, qui c'è un soma, qui c'è un pezzettino di dendrite, attacca il soma al dendrite, quindi a un livello molto più elevato di astrazione. Usava un linguaggio che si chiama H-Hoc, in cui non mi ricordo O-C, che cosa vuol dire, ma la H è l'iniziale del cognome di questo tizio, ed è una roba oscena, una sintassi terribile. Nel 2005, 2006, 2007, fra l'altro un tizio molto in gamba, un ricercatore molto in gamba canadese che conosco bene, Ilif Müller, insieme ad altre persone, ha creato un'interfaccia per Python, quindi se voi usate Python potete chiamare Neuron come se fosse una libreria e questo rende l'utilizzo di Neuron facile. Cos'altro vi devo dire? Se voi volete espandere Neuron, perché Neuron ha per esempio dentro di sé l'equazione di Hodgkin-Axley e basta, oppure ha il modello di corrente Leak, in cui si chiama meccanismo passivo e questa corrente passiva per lui è una modutanza che non dipende dal potenziale o dal tempo o da quello che è. Quindi quando voi volete dire, ok, crea un soma, tutto il neuron è un cilindro, quindi anche il soma sferico non lo riuscite a fare, però comunque è un singolo compartimento, vuol dire che qui, questo è un'unica variabile di stato, V1, e guarderemo prevalentemente, con un'eccezione, modelli a singolo compartimento, Potete dire, quindi questo lui di default è come se avesse C, demus o dt, questo ce l'ha. Quindi qui è come se questa roba qua avesse dei parametri geometrici, il diametro e la lunghezza, che poi alla fine sono semplicemente utilizzati per determinare il valore delle variabili in cui normalmente i valori sono specificati in modo per unità di superficie. Quindi specificando la geometria automaticamente lui usa nelle equazioni il valore corretto di capacità. E poi potete dire, sai cos'è? Metti qui dentro il meccanismo passivo e lui mette nella parte destra di questa equazione, mette questa corrente. Se gli dite metti il meccanismo HH, con molta fantasia lo chiamano H, vuol dire che lui dentro di sé ha il modello di HH con i parametri dell'articolo del 52 di Molchini-Huxley, quindi non necessariamente una cosa che, come vedremo più tardi, va bene per un modello di cellula corticale di ratto o di uomo, però per iniziare o per... lui ce l'ha dentro e quindi quando voi dite "inserisci questo meccanismo" lui vi aggiunge le correnti "voltaggio dipendenti" "sodio e potassio" però il concetto è che visto che io semplicemente devo dire letteralmente qualcosa che è "insert" lo vedremo dopo anche perché la sintassi non me la ricordo a memoria ma il comando è "insert" anche se lo usate una volta e poi fate come incolla non è una comprensione, un apprendimento di questa grande sostanza visto che in una botta soltanto in una riga fai insert, bla bla e lui non solo aggiunge le correnti ma tiene conto delle equazioni che descrivono vi ricordate m³ h, n⁴, INA-V, IK-V qui c'è, mi sto scordando, Gk e qui c'è G bar Na. Lui ovviamente mette anche le equazioni differenziali per M, N e H. E voi non dovete fare nulla, lo fa tutto lui. Magari quello che dovete fare è specificare le condizioni iniziali, ma tipicamente l'unica cosa che si specifica è la condizione iniziale di questa sola variabile di stato. visto che è così facile, allora uno dice ma sai cos'è? Aspetta, perché non lo uso per mettere altre correnti voltaggiosipendenti? per esempio ci sono delle correnti che sono correnti potassio transitori, cioè che hanno una inattivazione che hanno una qualche descrizione, che adesso non te la sto nemmeno a dire, la sbirgiamo dopo in cui nonostante questa sia una corrente potassio, ha una sua conduttanza potassio che è diversa da questa questa potremmo chiamarla potassio delay rectifier o anche persistente perché non ha una inattivazione come il sodio questo qui ha delle altre variabili, non mi ricordo se ha una inattivazione che non chiamo, che chiamo H per esempio comunque vi permette in una vuota sola di inserire un'altra corrente oppure una corrente sodio persistente che è un altro, misurato sperimentalmente, trovate sperimentalmente, esistono dei canali voltaggi dipendenti del sodio che non si inattivano, oppure ci sono delle altre correnti che si chiamano IH, sono attivate dall'iperpolarizzazione, sono canali che sono, se ricordo bene, sono permeabili sia a cariche positive che a cariche negative. Quindi visto che è così facile come dire inserisci questo meccanismo l'appetito viene mangiando e allora uno potrebbe dire e lo vediamo quanto sia facile inserisci anche questo inserisci questo quindi però questi meccanismi lui non ce li ha e per ognuno anche di questo e questo l'utente può creare un file mod che sta per modello la cui sintassi la vedremo e ancora in un altro linguaggio di programmazione si chiama model, quindi language model, ed è, non è particolarmente user friendly. Quello che si fa è, forse ve l'ho scritto su Teams, avete dei siti, uno di questi, lo vediamo, si chiama modelDB, quindi database di modelli, fate potenzialmente shopping di meccanismi. Ah, sai cos'è? Mi serve una corrente di potassio che si inattiva, IA. Mi serve... l'andate letteralmente a scaricare. Ora, tra il dire e il fare c'è di mezzo il mare, nel senso che se voi avete un esperimento, avete un neurone, volete fare un modello di una particolare cellula, in teoria dovreste avere dei dati sperimentali come quelli che hanno permesso Hodgkin-Axel di fittare le varie curve, le attivazioni, M infinito, H infinito, Tau, non è detto che ci siano, e se non ci sono, la cosa migliore che potete fare è vedere, ma qualcuno ha descritto la stessa corrente, magari in un'altra specie, e quindi magari fate un mix, che non è ideale, però piuttosto che non farlo, potete prendere la corrente IA che magari è stata identificata nel ratto, perché nell'uomo non è stata ancora identificata. Ci sono degli sforzi per uno di questi, è molto interessante, e si chiama Channelpedia, in cui in teoria per tutti i canali ionici, potassio, sodio, voltaggio dipendenti, vedete quanti ce ne sono, Calcio, cloro, TRP sono recettori che hanno... Quindi per tutti questi in teoria esiste una specie di database in cui ci sono le tracce sperimentali che vi vorrei far vedere. Qui ci sono tutti gli articoli che usano questo NAV 1.2, volevo vedere le tracce, trace, la cinetica, credo che siano questi alla fine, però solo nel mouse, non so se riuscite a leggere. e in effetti qui dice guarda che c'è l'implementazione per il simulatore neuron e se lo vuoi devi scaricarti questo punto mod file dove mcoh25 è perché il tipo di cellula cho è Chinese hamster ovary cell Cioè la gente non ha preso un neurone, ha preso questa linea cellulare, non ricordo onestamente perché è immortalizzata e non ricordo perché è stata originata da questo Chinese hamster, che fra l'altro è carino. quindi con metodiche di trasfezione o trasduzione a quelle cellule gli è stato fatto esprimere solo quel canale in modo tale che io arrivandoci con una pipetta potessi eventualmente studiarne l'attivazione e l'inattivazione in modo elettrofisiologico. Se già c'è, non è quello che uno può fare e si va a scaricare il file, qui non sono sicuro che sia questo, questo è un entry da quest'altro sito che ora vi faccio vedere, modeldb, il.science è un dominio, prima si chiamava.org fino a qualche anno fa, in cui il modello 230137 è legato a quest'articolo pubblicato nel 2017, in cui questi tizi hanno evidentemente studiato un modello, non è esattamente quello, perdono. Noi stiamo guardando questo qui, qui non so perché non c'è il riferimento perché questo è un meccanismo di Neuron. Mi chiedo se Google mi aiuta, no mi esce Channelopedia, ma se io vado su ModelDB. tolgo il wifi ma sono sempre connesso, quindi se io cerco questo meccanismo succede qualcosa o no? no, forse gli dà fastidio che è il punto mod no in teoria dovrei riuscire a recuperare questo meccanismo perché risulta a questo channelopedia che sia esistente non vi ricordo se qui per caso si possa scaricare comunque per farla breve potete fare shopping.dfile.mod e combinarli assieme in un modello questo è il vantaggio di Neuron cosa che invece se doveste farlo a mano dovreste programmare le singole equazioni non gli piace perché non ti piace ok La complicazione quindi è che Neuron è espandibile, però visto che Neuron è un programma compilato scritto in C o C++, che sono linguaggi di programmazione compilati, c'è una procedura intermedia che dice compila di nuovo Neuron incorporando quegli altri file e ovviamente diventa un altro eseguibile che dovete utilizzare, perché il nuovo eseguibile incorpora eventuali meccanismi che avete messo. Vi voglio dare questa premessa perché se no non capite adesso il codice che vi faccio vedere. Neuron ha anche una sua interfaccia grafica che vedete molto stile anni 80-90, 90 più che 80, e a me non piace, funziona, diciamo, è un reminiscente di architetture e di sistemi di finestre che non sono quelli sui moderni Mac, Windows e Linux, e ancora prima, sotto Unix sostanzialmente. Per questi esercizi, per questi demo, ce la caviamo solo con Python, usando le librerie di Python per fare un plot delle tracce che vengono generate. Questo mi richiede di dire a Neuron, visto che Python mi permette di parlare con lui, di dirgli quando tu lanci la simulazione, la traccia che produci mettele in un vettore, in un array di Python, in modo tale che io poi ce l'abbia in Python, perché se no restano dentro Neuron. Adesso lo vedrete più nel dettaglio a che cosa faccio riferimento. Il primo esercizio, il primo tutorial, quello che è, ha a che fare con un singolo compartimento, di cui alla fine questo è l'equivalente circuitale, in cui vedete non c'è soltanto la capacità di membrana, c'è anche la componente leak, assumendo che questa resistenza non sia voltaggio dipendente, tipica del meccanismo delle proprietà passive. E quindi è abbastanza facile. Io dico, a parte importare, questa è una forma standard in Python per importare una libreria, o un sotto insieme di una libreria, forse voi siete più skilled di me in Python, forse dovrei dire di importare un namespace, probabilmente sarà più corretto dire, in modo tale che tutti i comandi o le funzioni o gli oggetti che sono all'interno di questa libreria diventino disponibili. E questo n rappresenta il punto, la radice, il root di questa libreria. e per creare una singola sezione è così facile come dire, Soma, questa è una variabile a cui viene assegnato l'output di questo comando, e al di là del fatto che questo comando probabilmente è un costruttore, chiama un metodo costruttore di oggetto, che per la programmazione orientata a oggetti ha perfettamente senso, ma anche per uno che non sa nulla di programmazione di oggetti, e che non sa nulla di Python, e che non sa nulla di Neuron, uno si tappa il naso e dice, ok, qui crea una sezione e questo nome, Soma, è un nome interno che avrei potuto chiamare Pippo. Qui invece Soma è il nome di una variabile dentro Python, non è un'etichetta, questa è proprio una variabile, un oggetto, che ha dei componenti, come tutti gli oggetti, ha una serie di variabili e una serie di metodi. I metodi sono funzioni, le variabili invece sono cassettini dove potete scrivere delle informazioni. Un cassettino si chiama L, che è la lunghezza, tutto è un cilindro, quindi questa sezione, l'avrei potuta chiamare Pippo, punto L vuol dire che io sto parlando della lunghezza, e quindi punto L uguale a 10, per default, per convenzione e micrometri, assegno questa geometria e diam, stessa cosa per il diametro, assegno questa geometria, quindi ho un cilindro tozzo e basso, perché volevo che fosse una sfera e non ci riesco, quindi se il diametro è 10 lo moltiplico per pi e poi lo moltiplico ancora per 10 e ho la superficie laterale di questo cilindro, giusto, è 2πr per h, dato che il diametro è già 2r, quindi diametro pi per h, quindi è dell'ordine di 300 micrometri quadri, 314 micrometri quadri. Ok, vuol dire che tutte le grandezze saranno scalate sulla base di questa quantità. Questo insert è quel comando che dicevo, tecnicamente è un metodo degli oggetti, cioè una funzione che agisce, una funzione propria di quell'oggetto, incapsulata nell'oggetto, che agisce internamente sull'oggetto stesso. Quindi io facendo così, in una volta sola, io ho detto, nell'equazione differenziale che io non vedrò mai, perché non c'è, aggiungi quel meccanismo. Qui è un ulteriore oggetto che è iniziato a essere presente perché io ho messo questo meccanismo passivo e questo g pass è il g bar, la g barrato di quell'equazione, perché eventualmente lo posso cambiare. E qui mi serve poterlo cambiare perché, se vi ricordate, G e C, quindi sarebbe C diviso G, lo so perché sto pensando a RC, RC è un tempo, è la famosa costante di tempo, visto che la conduttanza deve andare al denominatore, C su G, mi interessa per esempio mettere dei valori che siano ragionevoli, che insieme a un microfarad per centimetro quadro che lui ha di default, della capacità, la scelta di G mi faccia avere delle costanti di tempo, Qui è tutto passivo, quindi è solamente un esponenziale crescente, decrescente, fa quello che vuole, comunque è un esponenziale ed è dell'ordine dei 20 millisecondi, 50 millisecondi, che sono tempi ragionevoli biologici, per esempio di un neurone corticale umano o di ratto o di quello che è. Qui c'è un'altra cosa con cui è facile mettere dei meccanismi, qui è un meccanismo, una pipetta, letteralmente un generatore di corrente e anche qua c'è questo oggetto che si chiama, quindi fossi stato io l'avrei fatto in modo diverso, avrei scritto soma.insert e qui iClamp, iClamp sta per Current Clamp, che vuol dire che voi avete un elettrodo che controlla la corrente, non il potenziale. Quindi è un generatore ideale di corrente, il potenziale fa quello che vuole, avete anche l'opposto, però qui usiamo solo lo stimolo di corrente, esattamente come l'anno scorso avevamo provato a fare carta e penna in questo caso, ottenendo la solita equazione differenziale del primo ordine, qui è in una botta, vedete, steam era una variabile che non c'era prima, a cui viene assegnato l'oggetto creato da questo comando e viene messo all'elemento 0.5, questo è un elemento che ha un singolo compartimento, però tutto il neuron è un cavo, è un cilindro, e si assume che ci sia una specie di coordinata lineare dove questo, anche se questo fosse lungo L o 2L o 3L, esiste una coordinata interna che varia fra 0 e 1, la percentuale della distanza. dicendogli metti l'elettrodo che non è un meccanismo distribuito perché questo avrebbe le dimensioni di micro Siemens al centimetro quadro se ho una pipetta, un generatore di corrente non è una densità di corrente è proprio una corrente che voglio mettere in un punto non distribuire nello spazio e quindi dico la voglio mettere a 0.5 qui comunque è un singolo compartimento quindi se anche voi aveste usato 0.1 sarebbe stato uguale, ma nel caso invece di un oggetto che è gestito internamente con il neuron in più sezioni, quindi lo vedremo con un dendrite, avete tante sezioni, l'elettrodo lo potreste mettere in punti diversi, specificando per esempio che anziché a 0, anziché al 50% della lunghezza lo mettete al 25, al 75% quello che è. Di nuovo qui è una cosa estremamente noiosa, però se voi avete un esempio, per analogia e anche eventualmente lo facciamo insieme utilizzando qualche large language model per vedere, per suggerire, potreste orecchiare, per analogia dovreste essere in grado di fare la stessa cosa, quindi non siate troppo spaventati da una roba del genere che uno dice, caspia mi devo studiare tutta la documentazione, in linea teorica sì, però se uno è smanettone o se ve la cavate, a meno che non siano cose particolarmente sofisticate per cui dovete guardare il manuale, però di solito gli ingegneri non guardano mai i manuali, quindi credo che sia normale. Ma la Limea è semplicemente un oggetto radice di tutta la libreria ed è l'accorgimento con cui, a mio parere, Python fa schifo, comunque è l'accorgimento con cui Python può dialogare con un altro programma. ti importo come libreria, quindi tu una volta importato mi esponi una serie di strutture, funzioni eccetera, però visto che se io utilizzassi, faccio un esempio, se la libreria avesse un comando plot e io non metto n.plot, Python assume che plot sia una funzione che sta nello scope, se fossi un computer scientist dovrei dire, quindi non è una funzione di libreria, la va a cercare nello scope del programma che sto scrivendo, non la troverebbe e si incavola. E' nella primissima riga, questo from neuron import N, perché uno lo filtra, perché dice ma che cos'è? Però è abbastanza user-friendly, tappandosi il naso e di nuovo questo elettrodo ha come caratteristica una caratteristica molto ridotta, cioè permette solamente di iniettare una corrente costante e uno dice ma io vorrei metterci una sinusoide, vorrei fare arzigogoli, no non puoi, non in questo caso, questo è soltanto un generatore di corrente ideale DC in cui hai un valore costante, qual è quello che si chiama punto AMP, quindi steam di nuovo è un oggetto, AMP, dur e delay sono delle variabili di questo oggetto, Uno è il delay, cioè adesso lo vedete ed è facile da capire, in cui dice quanto in ritardo volete che questa ampiezza di 0.01 nA parta, quindi in questo caso sarebbero 10 microampere, picco, perdono, possibile? P compare, ok, P compare, e quanto volete che duri, 100 millisecondi. Così facendo io ho costruito la geometria e la biofisica, si dice, cioè ho messo i meccanismi, qui è solo il meccanismo passivo, e ho messo altri meccanismi che non sono distribuiti, questi si chiamano point process, sono processi, meccanismi puntuali, mentre questo passivo, qui è il singolo compartimento, quindi non c'è distinzione, ma se fosse un cavo, come sarà? Dire inserisci pass o HH o quello che è, lui me lo inserisce a ogni sezione, perché ogni sezione lui me la tratta come se ci fosse un condensatore e poi dall'altro lato una resistenza a una batteria, un'altra resistenza a una batteria, per ciascuna di queste sezioni, eccetera, eccetera. quindi quando io dico metti delle proprietà passive e ho un cavo in effetti gli sto dicendo metti un meccanismo che sia distribuito nello spazio in questo caso non ha senso mentre l'elettrodo è un point process qui c'è la parte in cui esteticamente orribile in cui uno deve dire per favore riservami dello spazio in memoria che io possa leggere acquisire con Python, e di nuovo questi vector non sono quelli di NumPy, non so quanto voi avete smanettato con Python, normalmente si usano i vettori della libreria numerica di Python, perché quelli di default dentro Python non sono un granché, non sono performanti, hanno altre limitazioni che adesso non mi ricordo. Qui addirittura gli dico, no, riservami il tipo vettore dentro la libreria di Neuron. Questo lo chiamo SomaV, che vuol dire per quel compartimento, lo potevo chiamare Pippo, anche questo, Pippo2, l'ho chiamato Soma underscore V per dire voglio che sia, che contenga, è un vettore, voglio che contenga tutti i punti durante la simulazione del potenziale di membrana al Soma. E infatti gli dico, deve essere un vettore e poi con quest'altro metodo registralo da dove, registra che cosa? Questa variabile interna che ha questi underscore perché è restia a farsi usare dall'esterno, è nascosta e quindi la gente, però io la devo usare, quindi se io non lo so in anticipo qui è una mezz'ora nella documentazione del sito online. Ci sono tanti esempi, quindi alla fine nel giro di una mezz'oretta uno lo capisce. Ed è la variabile del potenziale nel compartimento al punto 0,5. Di nuovo lo faremo dopo. Se ho un cavo, io qui vorrei avere magari dendrite 1, dendrite 2, dendrite 3, vorrei che fossero dei vettori che mi registrano il potenziale di membrana a diversi punti dei dendriti. Faccio la stessa cosa per la corrente di stimolo perché mi piacerebbe che plottare quella che la, non so, vi vorrei dare uno stimolo DC che è l'unico che questo oggetto mi dà e voglio plottare sia lo stimolo che la risposta. Quindi mi conviene farmi dare, anche se lo stimolo lo so perché l'ho scelto io, e l'ho scelto di durata 100 millisecondi, che parte 20 millisecondi dopo il tempo zero, che è l'inizio della simulazione, ed è ampiezza 0.01 nA. Comunque lo voglio registrare e vedete che questo steam, come anche questo soma, sono le variabili che qui sono state inizializzate a questi oggetti complicati, steam e soma. comunque lo vedete poi, faccio la stessa cosa anche della variabile del tempo, voglio che durante tutta la simulazione io abbia anche il vettore del tempo, così con un qualche comando di plot, gli posso dare, immaginando che sia plot in un sistema cartesiano x, y, ascisse ordinate, asse delle x, asse delle y, variabile indipendente, variabile dipendente, voglio dirgli t virgola soma v, in modo tale che lui di default mi fa l'asse delle x giusto, non mi dà l'indice dei punti, mi dice qui sono 20 millisecondi, 22, 25, fino a quello che sarà la durata della simulazione, che definisco in questo modo. Qui è un errore, chiedo scusa, questo non è H, dovrebbe essere T, ma lo cambio dopo, semplicemente perché fino all'anno scorso non era N, il nome della libreria era H, ma comunque non importa. Questo è il delta T che di solito si omette. Neuron ha la caratteristica che in alcuni casi permette di automaticamente stabilire qual è il delta T migliore. E dentro di sé ha un algoritmo numerico, come ho detto, molto più stabile. Si chiama, se vi può interessare, se volete semplicemente cercarlo su Google, si chiama Arbolito di Crank Nicholson ed è importante perché questi tizi non sono stati coinvolti in neuroscienze, questa era gente che studiava l'equazione dell'infusione, se volete in matematica spesso uno si riconduce al caso precedente come molte barzellette dicono, semplicemente perché la forma dell'equazione è la stessa, se la forma è la stessa e io ci sono libri o matematici del secolo scorso che hanno, ok, prendo quello e lo importo, lo riuso nel mio contesto attuale. Il comando per far partire la simulazione che viaggerà da t uguale a 0, che qui non è inizializzato, fino a t stop 220 ms, è questo. Quando lo faccio andare, lui va e io non vedo nulla, perché non c'è nulla che viene plottato. Però queste variabili, somma v, steam current e t, spero che siano state popolate e lo sono. Il passo successivo è, anche qua, a me non piace Python perché è estremamente verboso, però con la matplotlib in particolare, non so nemmeno come si chiama questo, se è una sottolibreria di matplotlib che si chiama Pyplot e la importo in Python e per brevità anziché usare matplotlib.pyplot.blab, lo chiamo pltplot, per scrivere i suoi, i propri metodi in modo conciso, definisco qui un doppio asse, questa è una roba che uno impara sul campo o chiede a Google o a ChatGPT o quello che è, come faccio ad avere in un'unica figura due assi, scusate, due subplot, Due subplot che siano due righe, una colonna e dove sia relativamente largo e stretto. Ok, questo è il comando di Python per farlo e mi sputa fuori dei, credo che in gergo si chiamino handle, letteralmente delle maniglie, che io poi posso istanziare e dire voglio fare questo plot nel primo di questi due, lui che li chiama assi, in realtà sono due subplot, e quest'altro plot nell'altro subplot. Nel primo plotto T, virgola soma è di colore nero, black, nell'altro lo faccio grey e metto la legenda che questo è una corrente in nanoA. e la simulazione ha funzionato nel senso che qui ha fatto la curva di carica del condensatore se volete fare volete mettere dei meccanismi attivi adesso lo vediamo in pratica basta che voi facciate inserisci hh o inserisci altri modelli se volete fare un modello multicompartimentale ball and stick per esempio un soma e un dendrite non vi basta semplicemente dire crea una sezione che si chiama soma Dovete creare un'altra sezione che si chiama dendrite, lo chiamate come volete, e a un certo punto dovete dire attacca il punto per esempio di coordinata interna 1 del Soma al punto della coordinata interna 0 del dendrite, così sapete esattamente come sono raccordati questi cavi. Quindi potete pensare, riprendendo sotto mano l'equazione del cavo, quanto sarebbe notevolmente complesso fare la stessa cosa, qui ve la cavate con tre linee di codice, fare la stessa cosa scrivendo voi il codice da zero cercando di risolvere le equazioni. Tanto che in particolare la gente semplicemente usa solo questo simulatore quando le morfologie sono molto complesse, dove ci sono biforcazioni. In teoria lo potreste fare manualmente, ma impieghereste ore o forse giorni addirittura. Se potete implementare la geometria, incorporarla, includerla, per esempio facendo shopping da quel sito che vi ho detto neuromorfo.org, e semplicemente tutti questi pezzi li dovete solo popolare di meccanismi biofisici, passivi, Hodgkin-Huxley, quello che è, è una passeggiata, effettivamente è una passeggiata. Negli anni questo simulatore è molto migliorato, è diventato molto potente e la ritrosia che avevo io perché era quasi impossibile da programmare in quel linguaggio hoc, l'ho riconsiderato un po' ed è abbastanza user friendly. Allora, quello che faccio è andare nel GitHub repository in cui se spottate... prego. un attimo ok lei ha visto dt qui questo qua è il passo di integrazione numerica perché in teoria lo potrei cambiare non posso però cambiare il dx perché è calcolato sulla base del delta T. In questo caso del modello singolo compartimento è semplice perché addirittura conosco la soluzione analitica, tutto è relativamente smooth, non ci sono non linearità, non ci sono potenziali d'azione che rapidamente avvengono, quindi con questo delta T potrei giocare. Però normalmente uno non lo specifica ed è Neuron che lo dovrebbe scegliere automaticamente, particolarmente per il delta X, perché nello schema di risoluzione numerica di Crank Nicholson, che vi invito, se potete Google, perché ChatGPT o Gemini o quello che è, vi danno una qualche risposta. anche su Google, io sto difficilmente, in questo caso non mi ha scritto, di solito Google mi propone qui una parte sbrodolata dal Gemini che mi dice che cos'è, non mi piace perché mi sono abituato con l'occhio a vedere nelle hit di un motore di ricerca quali sono i siti che mi vengono fuori, se è il sito di conspiracy theorist bio blu degli anti-vax non lo guardo nemmeno, se vedo che è Wikipedia, ok ci clicco su e questo sostanzialmente vi viene con per esempio questo open phone, ok, ok, Simon Fraser University, non l'ho mai sentito però potrebbe essere, magari è un corso, lo guardo, quindi questo invece con i large language model non ce l'avete mi chiedo se, però no, è troppo fastidioso volevo vedere qui se c'era qualcosa in cui no, non riesco a spiegarvelo in modo particolarmente semplice Comunque, quello che vedete qua è un'equazione differenziale alle derivate parziali in cui avete la derivata rispetto al tempo e la derivata rispetto allo spazio. Lasciate perdere questa funzione che descrive nel modo più genere possibile quello che è il termine a destra dell'uguale nel secondo membro. dovrebbe essere sufficientemente, ecco per esempio qua, che a questa equazione continua voi potete rimpiazzare un'equazione discreta dove avete un delta t, dove avete un delta x e questi ui, quindi avete l'indice del tempo e avete l'indice dello spazio perché li avete discretizzati e qui come convenzione credo che la I sia per il tempo, quindi il pedice per il tempo e l'apice per lo spazio. Tanto per farla breve, questa cosa qua porta a un conto fra matrici, potete scrivere questa cosa qua in forma matriciale, ma comunque la scelta di delta T e delta X è specifica del metodo di Crank Nicholson, ovviamente adesso non lo rivedo in modo particolare su come delta X e delta T debbano essere scritti. Sono dentro al Google Collab di questo corso, dentro i notebooks, ci sono arrivato dal sito, ci sono arrivato da mgiuliano.github.io neuromodeling. Non è questo, vabbè, non importa, ci sono arrivato dal sito del corso e dentro il notebook ne avete qualcuno, per esempio iniziamo dal primo e per farli lanciare automaticamente dentro Google Collab uso questo link che me lo apre nel cloud. In teoria voi potreste scaricarlo, se avete Neuron installato sul vostro computer, potreste scaricarlo da GitHub e per scaricarlo da GitHub fondamentalmente dovrebbe essere semplice come cliccarci su e premere questo pulsante che è download raw file. Quando lo scaricate avete sul vostro computer un file IPNB che sta per IPython Notebook, che era il nome vecchio dei Jupyter Notebook. In teoria potreste o utilizzarlo con Jupyter sulla vostra macchina oppure copiare e incollare solamente lo spazio delle celle lasciando perdere questa parte di markdown in cui c'è qualche spiegazione, ci sono delle equazioni e guardare soltanto la parte delle celle che contengono codice. In particolare per questo collab, quindi sto utilizzando un computer remoto che non ha neuron installato, quindi ogni volta lo devo installare, però fortunatamente, e qui ho fatto in modo che le celle del codice venissero automaticamente nascoste, E questo si fa con questo, ed è una cosa propria di Google Collab, con questo hash at. Se io tolgo l'at qui non c'è più modo di collassare questa cella. Non che io vi voglia togliere il piacere di vedere il codice, però credo che inizialmente potreste, magari mi sbaglio, essere overwhelmed, sopraffatti da vedere un sacco di roba. Questo in particolare per come funziona Google Collab, è un comando che non è Python, tutto quello che io scrivo qui in queste celle dovrebbe essere Python perché Python è il kernel, il motore che fa funzionare questa pagina interattiva. Se io uso il punto esclamativo, si chiama escape, io voglio scappare dall'interfaccia di Python e mandare un comando alla shell. Non so quanti di voi usano la linea di comando su Windows, su Mac, non so se utilizzate PowerShell oppure su Mac si chiama Terminal. Voi potete scrivere dei comandi, anticamente si chiamava MS-DOS prompt e uno scriveva dir e aveva l'elenco delle directory eccetera eccetera. Se voi siete ingegneri magari vi sto insultando a dire una roba del genere. Qui con il punto esclamativo io sto chiamando pip che è una disgraziata però facile, un facile pacchetto, un eseguibile scritto in python per installare librerie che vengono scaricate automaticamente da un sito che si chiama pypy, se non mi ricordo bene. Comunque potete googlarlo. Mandandolo in esecuzione, lui impiega qualche secondo e sta scaricando Python. Dopodiché è finito. Quindi adesso la libreria di Python, come se io dovessi aggiungere la libreria NumPy, oppure Numba, oppure altri nomi di Panda, oppure non so quali altre librerie potete avere incontrato, la potete portare dentro Google Collab, a meno che non sia già di default installata, ma Neuron sicuramente non è installato. Quindi non faccio altro, non ho altri meccanismi, quindi non devo fare alcun processo di compilazione. Adesso fra un paio di minuti ci fermiamo. Faccio quello che era sfuggito la vostra collega, questo import neuron è abbastanza grande. import neuron bla bla, importo anche matplotlib, questo non chiedetemi che cos'è, è una standard library che permette di, di nuovo questo è un metodo becero per chiamare un file scritto in hoc, però se la vede lui in neuron, questa è una roba, lo carico, in effetti è hoc, però questo è un file dentro Neuron ed è una roba che si fa di default perché così facendo posso avere un sacco di accesso a delle variabili ad alto livello, quali il delta T, potete provare a commentarlo e vedere se funziona lo stesso, il delta T, il tempo T stop, T start, che altrimenti non sono esposte, se mi ricordo bene. E questo comando qui forse non è necessario, forse sì, mi dice che quando io uso la libreria matplotlib, piplot, i plot non mi devono essere creati, anche perché qui non potrei farlo, perché nel cloud non mi devono essere creati in una finestra sul desktop, perché il desktop non ce l'ho. io sto usando in modo in realtà si dice headless, cioè senza testa, senza monitor, un computer che è nei data center di Google, e quindi vorrei che lui quando genera una figura me la mette in line, in line vuol dire in line con questo Jupyter notebook. La eseguo, eseguo questa roba qua, non dovrebbe impiega pochissimi millisecondi e dopo di qua faccio esattamente il codice che c'è prima, che vi ho fatto vedere prima. Creo il Soma, gli metto i meccanismi passivi, creo l'elettrodo di current clamp, gli dico i valori, credo esattamente quelli che erano indicati prima, gli dico che voglio registrare il potenziale e la corrente di stimolo e anche la variabile T e poi non faccio altro. per igiene mia mentale lo voglio mettere in un'altra cella, mentre in quest'altra cella vorrei zampettarci, quindi vorrei che ogni volta che questa cella è eseguita lui rifà tutta la simulazione, quindi qui dentro sicuramente c'è n run, però una cosa importante che non c'era nella diapositiva, nella slide che vi ho fatto vedere prima, è che io ogni volta che schiaccio questo pulsante, ok va bene che lui fa n run, che mi manda in esecuzione, ma voglio che lui faccia il riavolgimento, rewind, voi non avete mai visto forse un registratore a cassetta, io voglio che il tempo venga riportato a zero, in modo tale che quando io dico run, lui me lo fa, mi evolve il tempo fino a t stop, perché se non faccio questa cosa qua, lui me lo fa una volta e poi visto che t è uguale a 220 e t stop è uguale a 220, run non ha alcun effetto. Questo è il delta T, questa è la condizione iniziale e questo è un metodo che avete visto anche sui notebook dell'anno scorso, proprio specifico di Google Collab, che vi permette di avere degli slider. non è obbligatorio, in teoria uno quando programma, quando fa delle simulazioni eccetera, non è che le vuole interattive, però aiutano un po', particolarmente quando sono così veloci che possono essere fatte quasi in tempo reale. Quindi questo hash sarebbe un commento, però mettendoci at param, lui sa che io voglio creare un elemento grafico di una graphical user interface e questo elemento deve essere un slider e questi sono il minimo e il massimo, sono gli estremi e qual è lo step di questo slider. un'altra cosa tipica e tutto questo l'ho scoperto googolando perché dicevo ma è possibile che non ci sia il modo per fare degli slider? Jupiter dentro Python ce l'ha gli slider, adesso non mi ricordo come si chiamano, ha una libreria che si chiama, non me lo ricordo però volevo evitare di mettere 25 librerie e appesantire le cose, ho scoperto che quelli di Google sono talmente tosti che hanno queste cose di default e basta che le mettiate come dei commenti. L'altra cosa specifica è che in questo commento all'inizio della cella se voi scrivete fra parentesi graffe run auto, lui ogni volta che qualcosa cambia qui la rimanda in esecuzione. Quello che rimanda in esecuzione è run, a parte le condizioni iniziali, e poi fa il plot. Lasciate perdere la label o il fatto che cambio i limiti verticali dell'asse per farlo esteticamente bello. Vi faccio vedere cosa succede, lo collasso perché se no non mi piace e quindi qui ho questo slider con cui posso cambiare l'intensità della corrente. Non è proprio in tempo reale, però vi assicuro che è sufficientemente rapido per sviluppare un'intuizione. Vedete che sto cambiando l'ampiezza della corrente di questo DC pulse e conseguentemente cambia la curva. per esperienza ho voluto cambiare i limiti e voluto tenerli fissati i limiti della prima figura fra meno 80 e 0 perché so che se non l'avessi fatto il Python avrebbe automaticamente scalato avreste visto più o meno sempre la stessa cosa io invece volevo che lo vedeste piccolo qua quando la corrente era piccola e grande quando la corrente era più grande però questo diciamo è boring è un transitorio degli archi di esponenziali però paragonate con quello che avete magari per questo vince Eulero con l'equazione differenziale che avete fatto perché anche lì probabilmente in due o tre linee l'avete fatto, però lì dovevate fare un ciclo for per dire a ogni step, aggiorna l'equazione differenziale discretizzala con Eulero qui in teoria io sto facendo una roba per cui se qui voglio mettere come farò fra breve un meccanismo HH, letteralmente io qua scrivo HH, lo rifaccio andare, lui ovviamente si incavola perché glielo devo aggiungere eventualmente, e lo rifaccio andare e in meno di due secondi ho un neurone eccitabile. Volete fermarvi per un po'? Ok, ci fermiamo 10 minuti, però mi dovete ricordare, avendo iniziato alle 2 e mezza, possiamo finire alle 5 potenzialmente, giusto? Alle 5, 1, 10. È un problema quando avete l'autobus? 5 qualcosa, però finiamo qualche minuto prima. Ok, ok, dai 10 minuti di pausa. - Quando creiamo i vettori, gli elementi del vettore sono i singoli valori di potenziale? - Sì, lo saranno. - E in questo caso il senso di fare questa cosa se già abbiamo creato il gradino di corrente? - No, perché, allora, fondamentalmente qua lei definisce, inizializza per un tipo, dice "soma" sarà un vettore, però non è che il vector lui sa, è come se lei ha mai visto il C, in C una variabile la definisce come int float double, qui è di tipo vettore poi ci deve scrivere qualcosa, deve linkarlo. E quello per la corrente dicevo io, cioè se noi abbiamo creato prima il gradino perché facciamo un vettore? Perché non ha creato un gradino, lei ha creato un meccanismo iClamp, che è orribile sono d'accordo. Ok, no io pensavo che in quel modo avessi già che... C'è un altro modo che però è più elaborato e io stesso non mi ricordo, l'ho fatto nel passato in qualche codice ma non me lo ricordo a memoria, in cui lei potrebbe generare a parte con NumPy una forma d'onda qualunque, un vettore lo riempi come vuole anche con numeri casuali e poi ne fa il replay attaccandolo, però non è banalissimo, è una riga ma adesso non mi ricordo, attaccandolo all'ampiezza così questo iClem... Quindi a PCMD non posso creare direttamente da qui? salto questa volta? no, no qui è io ti creo e poi ti attacco una roba che spero che tu mi riempia durante la simulazione anche perché semmo forse poi dopo non si può portare... non l'avrebbe, esatto non lo potrei portare, ma diciamo queste due righe in teoria potrebbe anche anche la T del tempo potrebbe anche non metterle la cosa interessante è che risolva l'equazione differenziale per la V ok le altre sono state No, perché si è incavolato perché dopo che avevo messo HH pass non c'era più, quindi lui non aveva più questa variabile interna. Inoltre ho ragionato che in teoria se io tolgo pass non sono sicuro che funzioni bene, funziona allo stesso modo. Qui ho letteralmente soltanto sodio e potassio, non ho leak e quindi il comportamento è diverso da HH. Infatti qui lui spara spontaneamente, secondo me è l'attività dovuta all'inizializzazione, se io questo lo inizializzassi a anziché meno 70 mili, non credo che gli piaccia questo, se questo fosse 65 e quello spike non ci sarebbe più. Non le so spiegare perché, è perché il sistema non è allo steady state per quel valore di inizializzazione, quindi quando io faccio andare la simulazione lui parte da quel punto lì e trova magari che a quel valore m, h, n non sono spenti, in particolare credo che sia m che è più depolarizzato e scappa, almeno uno spike lo fa. Però non è cruciale, credo che, non sono sicuro che senza il pass, senza il leak, io possa avere, ok, ho solamente, non so se fa il treno di spike. perché non so cosa succede in assenza del... quando sia il sodio che il potassio... ok, forse vince il potassio, quindi è come se fosse il potenziale di riposo, forse più basso, forse no, non lo so, dovrei pensarci. Comunque non è esattamente il modello di Hodgkin-Axley perché il modello di Hodgkin-Axley sta sparando. Funziona uguale dal punto di vista di generare delle oscillazioni, che poi sia realistico. Mettendoci questo leak credo che ci saranno meno spike. Perché serve più corrente per caricare la membrana, perché l'impedenza di ingresso, la conduttanza totale della membrana è più bassa, scusate, è più alta. Quindi la resistenza è più bassa e la stessa corrente crea una deflessione minore. Non è cruciale, non è cruciale. E' solo per dirvi che in un attimo ho cambiato il modello facendolo diventare attivo, che è una buona cosa. Ma quindi HH in termini di neuron? Sì. Cioè il metodo usato lo dico Leo? No, è sempre Crank Nicholson internamente e HH ce l'ha di default perché è così standard per onore, mentre la corrente IA non ce l'ha. La devo scaricare da un sito, per esempio. Dentro questi notebook io vi ho messo una directory e dopo la utilizziamo, in cui ci sono diversi mod file, in cui per esempio c'è un sodio transitorio. e se io lo apro e lo faccio grande vedete che ci sono dei commenti in questo linguaggio barbaro che si chiama model language in cui a un certo punto ci sono le equazioni questo è un potassio transitorio quindi ci sono due variabili di stato m e h le avrebbero potuto chiamare qualunque cosa tanto restano encapsulate, m infinito, h infinito, come se fosse il sodio, però a un certo punto i valori numerici sono diversi e in questo caso anziché essere come il potassio m cubo per h, evidentemente fitta meglio i dati avere m alla quarta per h, Quindi qui il potenziale di inversione è quello del potassio, non è del sodio, quindi questo è un modo per implementare equazioni dello stesso tipo di Hodgkin-Axian. Infatti qui sembra quasi che sia scritto a mano, sia un'equazione algebrica, non c'è un metodo di Euler. Visto che nella modellistica neuronale le conduttanze tipo HH sono così onnipresenti, lo stile, anche se non sono esattamente quelle, ma i valori, la cinetica e lo stile dell'equazione è la stessa dell'articolo di HH, Allora faccio qualcosa che mi permette di implementare su quello stesso stile in modo molto facile. Molto facile vuol dire in poche righe di codice, quindi qui ci sono le cinetiche, qui c'è la dipendenza dalla temperatura di cui non abbiamo mai parlato e non parleremo, qui ci sono le equazioni differenziali e qui c'è la forma della conduttanza, la conduttanza massima e il come dipende dalle gating variables. Grazie. e gli esperimenti che avevano visto che era più una dipendenza dall'operata del tempo rispetto all'intensità dello stimolo. Se guarda su Google e cerca Giuliano e Pulizzi, Pulizzi ragazzi, molto in capa di parlare, se abbiamo un ingegnato, un ingegnato, che è stato come a fare il dottorato in MedioGiro. In quel articolo lì abbiamo osservato che è presa una rete di ormai biologici, occultamente ingegnerizzata da Opsime, che sono un canale di ferrami, che è un vettore virale sensibile alla luce. lasciando luce in tutto il tempo, quello che significa è che tutto il tempo iniziava oscillare nella frequenza gamma, che è una frequenza che è associata alla locomozione e alla condizione. E' un po' che non succede, la frequenza gamma è in base a un'acqua, non sono già per i suoi messi. Lo sono in vivo, qui è un piatto di micro-elettro e la mente, Qui non c'è struttura, non c'è niente, tutte le persone sono reddite, quindi è sorprendente perché dando una volta a questo sistema, oscillarsi in modo di ritrovo. Grazie. spettro, si stessi, si strizza gli occhi bene e ci sono delle strisce, delle strisce mette, se la cosa ci sia una struttura temporale, la linea rossa che è la media temporale, in effetti compiene delle lucidazioni, un anno molto proprio della tua è prendo la faccia rossa e faccio lo spettrogramma che è qualcosa che è un parente della persona la domanda è come faccio a sono rigido e voi siete molto gentili che le persone parte di chi è importante per farlo vedere se vado un po' più giù c'è posso usare un modello matematico c'è un'unica figura posso usare un modello matematico però quella è la sicurezza questo modello e li parleremo insieme, si chiama "fire and break", non ci sono gli "spike". Io lì riesco a avere qualcosa che farà oscillazione di visione, fa una specie di "ping-pong" e tengo le oscillazioni. La mia ambizione sarebbe: non è che lo riesco a fare in modo più fisicamente realistico, quindi qualcosa che mi permetta di riprodurre l'esperimento in quelle stesse posizioni, perché la luce, adesso non vedo i dettagli, abbiamo scoperto che la luce cambia il funzionamento delle sinapsi. Non dovrebbe perché l'autogenetica di solito è flash la luce e l'inchiacidi. No, purtroppo le ustine sono espresse anche nei bottori sinaptici. E questo Rocco Pulizzi ha scoperto, in questo esempio di flashback, che le sinapsi sicali più la luce viene lasciata accesa, nuova in frazione di 1 secondo, tanto più entra calcio nella sinapsi. Quindi se io potessi combinare una rete di modelli, fare un modello di una rete di ferroni, dove le sinapsi sono sinapsi che hanno una specie di barriere del calcio, io potrei simulare che cosa succede se uno stimolo che non modello cambia la luce, quindi dipende dalla luce, cambia il calcio in un'aspettativa che dovrebbe vedere delucinazioni a frequenze diverse. Questo è in anaccio il tipo di tesi. E posso raccontare un'altra cosa se vuoi. Sì, mi raccontare il teatro. Quindi sarebbe due e mezza. Quindi sarebbe 5.45. Quindi sarebbe... no, sarebbe 4.45. Sarebbe ancora un'ora. Quindi facciamo un'ora soltanto adesso fino alla fine? Ok. Ok. Ok, quindi qui vedete che questo meccanismo rende facile la simulazione. Una prima cosa che possiamo provare a fare insieme, o se volete provare, se state seguendo su questo stesso tutorial provare a fare, o la provate a fare a casa, perché può essere che darei precedenza a farvi vedere tutti i notebook e poi eventualmente torno indietro. Qui sul notebook ce l'avete la soluzione, però potreste provare, qui non vi faccio vedere il codice, a caratterizzare la cosiddetta curva corrente potenziale, cioè a dire se io qui cambio l'ampiezza di questo impulso, questo valore qui di steady state, Alla fine l'abbiamo addirittura, credo, fatto analiticamente, abbiamo fatto carta e penna. È un esponenziale, è una somma di due termini, uno è un termine costante che dipende dalla corrente iniettata, l'altro è un esponenziale che a un certo punto sparisce. questo valore qui vedete che si abbassa all'abbassarsi della corrente, a un certo punto diventa zero e a un certo punto diventa negativo. Sperimentalmente si usa fare esattamente questo protocollo, esattamente come lo sto facendo adesso, a un certo punto se la cellula è eccitabile, a un certo punto la curva non fa più così, inizieranno ad esserci degli spike. ma conviene, e spesso si fa, plottare su un piano cartesiano una serie di punti che hanno come coordinata delle X il valore dell'impulso, dello step di corrente che sto utilizzando io. In questo caso è 0.005 nano, quindi sono 5 pA. E nell'ordinata, quindi l'altra coordinata di questo punto, è il valore del potenziale. Dire valore del potenziale voi mi dite, ma guarda che questa è una roba, c'è un transitore, c'è uno steady state, e magari qui lo steady state l'ho scelto, qui lo steady state l'ho scelto, perdon, ho scelto la durata della stimolazione elettrica in modo tale da far raggiungere e permanere per un po' la traccia allo steady state. Io so che la soluzione deve essere una roba che la somma fra una costante e un esponenziale decrescente. automaticamente l'esponenziale decrescente sparisce aspettando un tempo infinito, però in pratica basta aspettare 2, 3, 4 costanti di tempo ed è finito. Quindi per fare questo grafico io posso convenzionalmente dire, potrei prendere l'ultimo punto, l'ultimo punto prima di spegnere la corrente, quello sarebbe la migliore approssimazione dello steady state, perché più aspetto tanto più è allo steady state. Quello che si può fare è, pensando a un esperimento vero in cui la traccia è un pochino rumorosa, quando il potenziale va su, non prendo l'ultimo punto, magari prendo gli ultimi 100 millisecondi e poi qui calcolo la media, la media aritmetica, average, di tutti questi punti. Così ottengo un numero, un numero solo, e posso plottarlo in funzione della corrente. Quindi questo è quello che in teoria potreste ottenere. Se volete potete provarci. Qui c'è la soluzione, però se volete potete provare a non guardare la soluzione. E quello che ho fatto qui con la stessa cosa è che ho messo dei controlli in modo tale che se io voglio estendere questo campionamento, posso per esempio andare anziché a 0,5 posso andare a 0,1 nA, ok, mi va fino a 0,1 nA in cui il corrispondente potenziale di membrana va fino a oltre 20 millivolt. Quello che fondamentalmente fa questa procedura è simulare una procedura sperimentale dove l'interesse è di stimare questa quantità qua. Quindi è come se io registrarsi da un neurone che ha questa equazione come equazione. Il neurone è vero, non è un modello, ma io fingo che sia un modello e spero che queste correnti, tutto quello che è oltre, non venga attivato perché il potenziale, in questo caso gli sto dando una schicca, una botta di corrente tale che addirittura va a più 20 millivolt, però il semifermo ha come era prima una frazione, probabilmente queste correnti attive non intervengono, quindi io sto solo solleticando questa corrente qua e allo steady state questo non c'è più, sto stimando questa o l'inverso di questo. E questo si fa perché mi dà immediatamente informazioni sulla dimensione della cellula, perché più o meno io so qual è il valore della conduttanza di Leak passiva e vi ho detto che il cilindro in una simulazione moltiplica l'area del Soma per questa grandezza specifica. e quindi in teoria quanto più o meno è grande la resistenza, alla fine questo è un piano V-I, quindi è una retta, quindi è come se fosse V uguale costante per I, che è la legge di Ohm. E la legge di Ohm, quindi la retta, l'ho tracciata con questa curva, con questa linea tratteggiata. E la linea tratteggiata vedete che passa esattamente in modo perfetto dai puntini. Perché vale la legge di Ohm? È un resistore. Sperimentalmente quanto più è grande la resistenza, tanto più è piccola la cellula. E quindi questo è un protocollo sperimentale utile. Vi faccio vedere l'altro notebook, però qui devo ammazzare altrimenti lui si incavola, quindi disconnect and delete runtime. dopodiché vado sul numero 2 che è un compartimento singolo però in un caso attivo devo installare Neuron appena lui si connette lui reinstalla Neuron. Allora, quello che viene fatto qui è una cosa un po' fastidiosa. Se voi avete mai usato Google Collab, voi avete in effetti un computer in remoto che ha una specie di spazio disco. Lo spazio disco in effetti potrebbe, ma è un po' complicato, potrebbe montare il vostro Google Drive, però in teoria questo spazio disco è uno spazio disco di una macchina virtuale, di un computer a sé stante, che quando voi premete disconnect and delete viene cancellato. E i programmi in esecuzione, se cercano qualche file, come per esempio il.mod, li cercano nella directory corrente. Se voi siete smanettoni di Linux, saprete che se creo una cella di codice e anziché fare questo escape pip, io faccio escape ls, ls è un comando linux unix bash che vuol dire list, è come l'equivalente di dir. e eseguo questa cella, lui mi fa vedere il contenuto della directory corrente, in questo modo me la fa vedere in modo lungo e mi fa vedere tutti i file, anche i file nascosti come questo.config, non so quanto ne sapete di queste cose. Quindi in teoria se Neuron si aspetta di trovare i mod file che adesso gli faccio compilare nella directory corrente, Io in qualche modo li devo portare questi file. Un modo sarebbe questo. Io ho sul mio hard disk dei file, per esempio, questo qua. E per trascinamento, lui me l'ha messo qui. Adesso lo cancello perché comunque questo file non me ne frega. Aspettate, vi faccio vedere che facendo ls-la, adesso me lo fa vedere. Perché sono le 13.54? Perché il tempo UTC, non è il tempo Central European Time. Ok, non importa. Questo lo cancello. Quindi se io avessi i meccanismi sul mio computer potrei portarli e trascinarli. Solo per farvi vedere un altro modo, che ho scoperto da poco, è possibile con Google Collab avere una cella, se volete una specie di metacella, nel senso che non è una cella che contiene codice e non contiene nemmeno markdown, annotazioni. Ha un comando che si chiama write file che come il nome suggerisce scrive un file di testo che lo chiamo nav.mod che ho copiato e incollato da questo link di questo modello qui ed è quello che durante il break facevo vedere a un vostro collega. cioè è il modo per aggiungere un meccanismo, in questo caso di una conduttanza, quindi non HH, che lui pensa che sia sodio e potassio assieme. Io qui voglio essere molto accurato e voglio mettere il canale sodio e voltaggio indipendente che io decido, e lo prendo da questo articolo, e un altro che l'ho preso da un altro articolo, il potassio che l'ho preso da un altro articolo. Vi faccio solo vedere che a un certo punto qui c'è l'equazione che vi è familiare, cioè la corrente sodio, che è la conduttanza per V-E-NA, dove la conduttanza è, a parte questo termine che è il fattore della temperatura, ma per il momento ce ne ferghiamo, G bar, G bar Na del sodio, M cubo per H, M per M per M per H, dove M e H sono variabili di stato, vedete qui è una sintassi che se fosse possibile eviterei di guardare, dove questo è un modo di specificare le equazioni differenziali che voi siete stati abituati a guardare nel caso delle gating variable delle conduttanze sodio. Facendo così, eseguendo questa cella, alla fine non so se sia un modo potente oppure no, però per darvi solamente un notebook a voi, in questo modo ho tutte le informazioni contenute dentro e quindi se premo ok lui scrive un file e facendo refresh lo vedo comparire qui. ho fatto questo in modo tale, lo ripeto, per darvi un unico notebook quindi questo notebook c'è una specie di sistema per creare il meccanismo nella directory locale qui è un altro per KV, le condutanze potassio-voltaggio-dipendenti che apparirà fra poco se non appare faccio, quindi K-Delay-Rectifier l'ho chiamato faccio anche questo che sono le correnti funny, IH non mi ricordo perché c'è però ok e dopodiché in questo caso specifico, visto che ho dei mod file nella directory corrente li voglio usare, voglio che Neuron li incorpori dentro se stesso e purtroppo devo utilizzare una procedura che su Google Colab è un po' fastidiosa di nuovo con un comando che è questo escape quindi è un comando della shell è un comando come se fosse da linea di comando non è python e neuroniv non mi ricordo che cosa sta model l compila i mod file scritti in mod l che è quel tipo di sintassi questo linguaggio per specificare la cinetica, le contatti, che non è granché, però c'è. Se io lo mando in esecuzione, lui letteralmente sta utilizzando un compilatore C, infatti vedete che questi meccanismi sono stati convertiti in un file c.cpp, che il suffisso potrebbe chiamarsi come si vuole, ma per convenzione se è.c è un file c, se è.cpp è probabilmente un C++. E lui ha creato una directory x86-64 che per convenzione, perché evidentemente la piattaforma su cui sta funzionando questo Google Collab, è un'architettura Intel del tipo qualcosa 86, 64 bit e qui dentro ci sono non soltanto i punto mod che sono stati convertiti in C++ e non ce ne frega niente, Ma c'è soprattutto questo eseguibile che si chiama special. Ora se io faccio andare, non sono riuscito a semplificarlo in modo ulteriore, se io eseguo il codice di Neuron adesso, lui non riesce a utilizzare special, usa Neuron l'eseguibile che aveva prima. Io invece voglio che utilizzi quello nuovo, quindi ogni volta che sono a questo punto all'inizio, almeno una volta, devo andare su runtime e devo fare restart session. Però nulla di male, non devo... What happened? interessante ok allora datemi un secondo era il 2 installo neuron compilo quando lui mi dice che è felice e contento che ha creato il file special io restart session ok e adesso lo posso eseguire esattamente quello di prima creo il modello in questo caso non inserisco solamente il meccanismo passivo gli dico già che adesso ce l'hai dentro di te incorporati inserisci il meccanismo potassio di layer rectifier e sodio di layer rectifier con questi valori di conduttanze massime. Non mi ricordo se i valori di default che avete, anche senza specificarli, erano sufficienti per avere comportamento eccitabile. E anziché usare HH, volevo farvi vedere che in teoria io posso prendere delle conduttanze, letteralmente ho fatto shopping, come vi ho fatto vedere. Qui addirittura specifico la temperatura, perché voi la possiate eventualmente cambiare. E per il resto è identico, nel senso che c'è un meccanismo, un elettrodo, dovrebbe essere esattamente identico qui lui lo esegue non mi dà errori quindi sono contento e questo è esattamente lo stesso setup in cui metto t uguale a 0 faccio la simulazione per 220 ms l'ampiezza dello stimolo è come quella di prima forse l'ho abbassata un po' nel valore massimo così che voi non poteste andare poi uno lo può forzare e poi faccio il plot solo che in questo caso dovrebbe essere la risposta di un modello che ha il comportamento passivo e poi ha il sodio voltaggio dipendente e il potassio voltaggio dipendente. In questo caso se piano piano aumento, ok, vedo che quello che non riesco facilmente a farvi vedere è che con queste conduttanze, al contrario del modello di Hodgkin e Huxley, forse cambiando lo step e mettendolo più fino, leggermente più fino, Io riesco ad avere frequenti arbitrariamente basse, cosa che col modello di Hodgkin-Axley non poteva essere fatto per motivi matematici, ma forse anche questo è un modello che o inizia a sparare direttamente a 3 spike ogni 220 millisecondi. Comunque non importa. Qui avete facilmente lo studio delle proprietà attive, in cui posso poi bombardarlo di corrente, speriamo che no, anche se gli do tantissima corrente, il numero degli spike aumenta. Qui non è sorprendente, è sorprendente il fatto che sia stata fatta questa simulazione in modo molto molto semplice, al di là del fatto di installare Neuron e di compilare i meccanismi, però sul vostro laptop lo fate una volta sola e quei meccanismi di quella simulazione sono pronti per tutte le altre volte. Lo stesso esercizio, se l'avete fatto, se provate a farlo per il caso precedente, fate letteralmente quasi copia e incolla in questo caso, dovreste riuscire a ottenere qualcosa del genere. Quindi esattamente il tipo di mimare, il tipo di esperimento biologico in cui però in questo caso i punti non seguono una retta, non seguono la legge di Ohm e il motivo non è particolarmente sorprendente, vuol dire che le altre conduttanze attive che sono nel membro destro, nel right hand side, nel secondo membro di quell'equazione, non sono proprio spente a potenziali attorno a meno 80, meno 78, meno 76. Alla fine lo sapete perché le cinetiche di quei M infinito, N infinito e H infinito non è che sono zero, sono delle sigmoidi, quindi a un certo punto iniziano a piegare, cioè anche a meno 70 avete delle conduttanze voltaggio-dipendenti che sono attive, Tanto che basta per creare delle deviazioni rispetto a quello che sarebbe il caso puramente passivo. E quello che sperimentalmente facciamo in laboratorio è che comunque cerchiamo di fittare una retta perlomeno nella parte iniziale dove la curva è lineare, quindi in questo caso la diagnosi sarebbe, ok, sto andando troppo, sto depolarizzando troppo, anche se meno 72 non è particolarmente depolarizzato. e quindi se anziché 001 vado a 0005 lo faccio più piccolo, lo faccio ancora più piccolo, non stai funzionando? Perché non stai funzionando? No, sta funzionando. Però allora devo addirittura mettere una corrente negativa. Quindi devo mettere... Ok. No, ok, devo mettere... Scusate, mi sto imbrodando perché è negativo. Sto cercando di mettere meno 0,01, non mi viene in mente un numero fra meno 0,01 e 0. Quindi deve essere un numero più piccolo in valore assoluto. Sì, quindi dovrebbe essere 0,1. Se io metto qui 0,6, quindi se io non do troppo fastidio alle conduttanze attive, qui la vedo la relazione lineare o quasi lineare e tipicamente quello che la gente fa è sperimentalmente prendere la pendenza di questa retta con questi punti e la chiama impedenza d'ingresso, cioè assumo che sia l'inverso di quella conduttanza di leak. Nella realtà quello che uno fa è iniziare a fare diversi pulsi di corrente e a un certo punto questa procedura di prendere la media di questi punti alla fine della risposta al gradino, negli ultimi tot 10-20 millisecondi, vedete che è scombinata perché probabilmente per questi valori qui, per esempio 0.04, il neurone ha iniziato a sparare. se io metto qui, non lo posso fare, 0.04, qui ho degli spike, quindi la stessa operazione che mi aspetto mi avrebbe dato un numero perché per stimare a meno delle fruttuazioni di quello che è questo valore di steady state, in realtà qui ci sono degli spike, quindi ok, lui mi calcola la media però me la calcola tenendo conto degli spike invece non era quello che volevo questa è la ragione per cui questi punti qui sono scombinati sono completamente off non è più il comportamento passivo che mi aspettavo di trovare questo potrebbe essere utile e l'altro, adesso vediamo col tempo ma almeno vi faccio vedere quindi questo come esercizio un altro esercizio che se volete proviamo a fare sarebbe quello di trovare la curva frequenza corrente, cioè la curva che mi dice quanti spike ci sono per quel valore della corrente. Mi fa un grafico in cui sulle x c'è la corrente, come adesso, quindi internamente lui deve fare tante simulazioni quanti sono i punti che gli sto chiedendo, Quindi da qualche parte ci sarà un ciclo FOR, FOR di Python, e per ogni iterazione del ciclo FOR dico a Neuron, manda una simulazione, però questa volta cambia la corrente. Quindi alla fine è praticamente identico il codice se avete risolto questo problema qua, la cosa in più è che devo contare gli spike, ma se non mi ricordo male, gli spike c'è un meccanismo, come c'è un meccanismo per, un point process, come c'è un meccanismo per iClamp, forse non è qui, forse è qua, c'è un meccanismo per contare potenziali d'azione, che qui non c'è, ma se io cerco APC, action potential count neuron point process, Questo è perché lo so e l'ho usato altre volte. Perché è così lento. Perché Yale è lentissima. APC. Quindi in qualche modo se io gli dicessi n.ap count, action potential count, dandogli la soglia di detezione avrei una roba che mi permette di, senza fare sforzo, di contare quanti potenzializzazioni ci sono. se non usate questo meccanismo qua dovreste guardare la traccia qui, voi avete questo vettore in python, punto dopo punto dovreste trovare un modo, inventarvi un algoritmo che si chiama peak detection ed è facile, basta che ci pensiate per qualche minuto e vi viene in mente in cui dovete trovare l'attraversamento di soglia, di una soglia che decidete voi e che mettete per esempio, in questo caso lo potete mettere a zero. In alcune tracce sperimentali potete avere talmente tanto rumore, oppure viceversa gli spike potrebbero avere una variabilità nell'ampiezza, anche se dovrebbero essere tutti altri uguali, che se mettete una soglia fissa senza aver guardato i dati, magari vi perdete alcuni spike. Se però la mettete troppo bassa non li contate più, quindi dovete guardare i dati e dare questa soglia. e dovete riuscire a beccare l'attraversamento solamente, tecnicamente si dice con derivata positiva, però dal basso verso l'alto. E per farlo un modo semplice è che abbiate, quindi ricordatevi che è un vettore e un insieme di punti. Quindi voi letteralmente potreste immaginare di mettervi, di fare un cicloforo in cui vi mettete ogni volta su un elemento diverso di questo vettore e vi chiedete ogni volta sono sopra o sotto la soglia? sono sopra o sotto la soglia? vado avanti se sono sopra la soglia ma prima non ero sopra la soglia allora prendo un contatore e lo incremento e non lo incremento più dopo se sono sopra la soglia sì ma anche prima lo ero quindi tipicamente uno può usare una variabile booleana temporanea o anche 0,1 per dire se sono sopra o sotto qui sei sotto 0 qui sei sopra 1 quando sei sopra e la tua variabile era 0 allora quello è uno spike lo contate solo una volta perché se no lo contate tante volte quanti sono i punti sopra soie è una cavolata però dovete pensarci può essere utile per fare pratica di un elementarissimo signal processing qui non dovete filtrare niente perché una simulazione è tutto pulito, poi difficilmente si filtra uno spike train perché si rischia di cambiare le proprietà, è già un amplificatore che ha un certo filtraggio, oppure utilizzate quel meccanismo APC di cui dovrei avere un esempio. ora vediamo, non credo che ce la facciamo perché almeno vi faccio vedere tutti questi tutorial e potreste provare a giocarci, non è obbligatorio, se lo volete fare lo fate dunque github di nuovo qui il terzo notebook è questo lo stacco perché sennò lui si incavola che non ne possa avere troppi aperti allo stesso momento e il numero 3 in cui vi faccio vedere un modello multicompartimentale ball and stick prendo tempo e mando in esecuzione l'installazione di neuron No, questo non l'avrei dovuto fare. letteralmente due frasi. Qui è un modello multicompartimentale in cui avete un Soma che è un singolo compartimento e un Dendrite che è più lungo e il codice è questo qui. Capirete perché questa è la solita cosa di importazione delle librerie. e qui ciao arrivederci qui e per la prima volta vi faccio vedere che non faccio solamente una sezione e la chiamo Soma ne faccio anche un'altra e la chiamo Dendrite di nuovo queste etichette possono avere il nome che vogliono però mentre il Soma lo faccio di lunghezza e diametro uguale il dendrite lo faccio diverso lo faccio di questa variabile che è il mio slider, voglio fare che cambiando lo slider il dendrite diventa più o meno lungo e al contrario di prima io qui esplicitamente dico che voglio che qui in effetti la scelta di questo numero è un po' tricky però per il momento non ce ne frega niente sia descritto da 51 singoli compartimenti, perché voglio che abbia un'estensione spaziale, non mi basta che sia un singolo compartimento, voglio che sia una struttura spazialmente estesa. E sono io che scelgo quanto fitto deve essere la descrizione, tanto più fitto, tanto più io posso in teoria dopo o mettere degli elettrodi per registrare o mettere dei generatori o degli input o delle sinapsi per stimolare in quel punto. Qui metto, allora nel Soma metto un modello che è tipo HH, si chiama di Wang Buzzaki, ma non importa, è un modello per avere un'eccitabilità però solo nel Soma, mentre nei dendriti metto soltanto questo modello passivo, quindi è un modello in cui nel Soma ho le condottanze sodio e potassio, voltaggio dipendente o anche leak. mentre in tutto il dendrite ho solamente il leak, quindi non è un assone, è un dendrite, alla fine se avessi fatto diversamente, adesso vi faccio vedere in un attimo, lo posso fare, se avessi messo anche qui i meccanismi eccitabili sarebbe diventato un assone, e infatti vi faccio vedere la differenza. Adesso è un modello passivo. I dendriti della maggior parte delle cellule probabilmente sono passivi, con alcune eccezioni notevoli, in particolare nella corteccia e anche nell'ippocampo, dove ci sono delle conduttanze voltaggio-dipendenti anche nei dendriti. E non è detto che le conduttanze siano espresse allo stesso modo in tutti i punti. Ci sono, e l'abbiamo visto nel caso della, quando abbiamo menzionato la dendritic democracy, non so se vi ricordate questo termine, in cui le proprietà, in quel caso del campus cellulare, dipendeva dall'espressione di canali nell'albero dendritico. e adesso non mi ricordo se la particolare conduttanza non era nello spazio uniformemente distribuita, ma era, supponete, più elevata al Soma e poi man mano andava esaurendosi, man mano che andavate, vi allontanavate dal Soma. Tutte queste cose, cioè la scelta dei gradienti, non ve lo faccio vedere, però potete immaginare che con Neuron sia una passeggiata, perché tutta la complessità sottostante viene nascosta. NSeg dà la possibilità di specificare che una struttura, un elemento, ha un'estensione spaziale ed deve essere descritto da più variabili di stato. Non è descritta da un unico potenziale di membrana, ma da 51 potenziali di membrana. Questo ha un effetto perché il valore della lunghezza del dendrite è elevato rispetto a quella quantità che si chiamava space constant, costante di spazio, che è legata a parametri biofisici che sono qui di default, per cui la resistenza assiale e la capacità di membrano, forse la capacità non c'entrava niente, era la resistenza assiale, il diametro e qualche cos'altro, non me lo ricordo più, motivavano il fatto che le grandezze non fossero istantaneamente allo stesso potenziale, non fossero isopotenziali. E gli dovrebbero fare anche il somma? Sì, però probabilmente non avrebbe effetto perché il somma è piccolo, quindi tutte le variabili lo possiamo provare a fare. Tutte le variabili avrebbero, anzi vi faccio vedere una cosa che potrebbe convincervi, faccio il dendrite adesso molto molto corto e vedrete che il potenziale di membrana misurato in tre punti diventa praticamente coincidente. Però è un ottimo punto. Quindi credo che sia qui il fatto che con questo ciclo for in cui non mi piace Python perché rende alcuni comandi simili al, o forse voi ne siete innamorati, ma per me è troppo conciso, in alcuni casi è troppo conciso e questo è un, credo che si chiami iteratore, Io sono abituato a un ciclo for a definire un indice, a definire un range. Qui dend è un oggetto fatto da più sotto oggetti e questo ciclo for in Python permette di iterare sull'intera collezione dove questo seg diventa l'elemento generico. A me non piacciono una roba del genere, però effettivamente dal punto di vista del codice in una linea ho fatto una cosa che avrei fatto in due o tre linee, in C o in qualche altro linguaggio. Ve lo sto dicendo perché in questo caso qua io sto navigando lungo tutte le sezioni o i segmenti, o sezioni, mi confondo, una delle due, tutti i 51 segmenti, sezioni del dendrite e per ciascuno gli sto mettendo esattamente lo stesso valore. Se avessi un comportamento che cambia, se volessi descrivere una densità di distribuzione di questi canali che cambia nello spazio, lo potrei fare qui in modo semplice come in questo caso. Potrei metterci per esempio un gradiente del potenziale di reversal, per esempio moltiplicando per la coordinata di se, vorrei che fosse qualcosa che cambia da meno 65 a meno 70 con una qualche legge di andamento lineare, però non so, lo vediamo a limite dopo, come dargli in pasto quello che è, per questo ciclo for non mi piace. Il valore del seg, la distanza poniamo da un'estremità, oppure quella variabile lineare fra 0 e 1. Qui non credo che sia seg. Possiamo provare, ma secondo me si incavola. Vi faccio vedere che succede. Anzi no, prima vi dico che ho messo 3, 4, sto registrando 4 vettori. Non mi piace perché l'ho fatto qui tutto in una botta, vabbè, ok. In una riga soltanto gli dico, crea dei vettori per v-soma, v-dend starting point, v-dend midpoint e v-dend end point. E registra, ok, il soma al punto di mezzo, 50%. Il dendrite lo fai al punto 1, punto 5 e 1. Se volete lo possiamo cambiare, potremmo farlo 0,25 o quello che è. 0.25 e altre estremità. Se io faccio andare questo codice, vedrete che è plotto tutte e tre le grandezze. Vedete che più o meno gratis ho la possibilità di esplorare l'equazione del cavo. Però volevo... Urca. Perché è così brutto? non so perché questo slider me lo stia facendo così unbounded quindi se io faccio la lunghezza dell'endrite molto piccola che è 60 micrometri il somma è credo 20 micrometri quindi è ancora più piccolo il potenziale di membrana registrato nel dendriti quindi è stato generato al soma perché nel soma ho iniettato uno step di corrente e qui ho misurato l'eco il cosiddetto back propagating action potential che nei dendriti è un fenomeno che è stato alla fine negli neuroni corticali è stato scoperto da più di vent'anni ma non era noto non si pensava che il potenziale di azione andasse soltanto verso l'assone. Per farla breve vedete che qui la traccia nera del Soma, rossa del dendrite al 25%, che nel caso di 30, 40, 50 micrometri è 5 micrometri, a metà 25 e alla fine 50, praticamente sono tutte sovrapposte, cioè è effettivamente un sistema isopotenziale, nonostante sia descritto da 51 sezioni. Se invece aumento pian piano la lunghezza, adesso siamo a 200 micrometri, lo leggo da qui che è il punto massimo, uno è il Soma e gli altri tre sono... Vedete che non solo c'è un'attenuazione, ma c'è uno spanciamento e tenete presente che per esempio in una cellula corticale Anche di ratto il dendrite, supponete, può avere anche una dendrite apicale, di una cellula piramidale, può avere una lunghezza di anche fino a un millimetro, supponiamo 600-800 micrometri. E vedete che il potenziale d'azione che è circa 20 mili volte al Soma è praticamente c'è, quindi la eco c'è ma è molto attenuato, è molto spanciato. La cosa interessante che si vede è che qui chiaramente si vede qual è, per via dei ritardi, si vede che chiaramente parte prima il nero, poi parte il rosso, poi parte il blu e poi parte il verde, descrivendo una propagazione passiva di un segnale. la cosa che posso fare immediatamente è di mettere nei dendriti non solo il meccanismo passivo ma anche il meccanismo attivo, questo Wang Guzaki che per semplicità vi ho detto essere sodio e potassio se lo faccio e in questo caso però scusatemi prima avevo cambiato e mi era piaciuto che avevo messo il dendrite al 25% perché sennò è troppo vicino al soma e non mi dà particolare soddisfazione perché è praticamente identico al soma quindi qui quella roba lì quel cavo è diventato un assone anche se è un assone non mielinato perché nel caso della mielinata l'illenizzazione avrei dovuto fare qualche cosa di un pochino più complesso. Tutto è citabile, tutti e 51 i segmenti sono individualmente capaci di generare un'opposizione d'azione, esattamente come la conduzione in un assone, in prima approssimazione. Se io lo faccio, aumento la lunghezza, ricordatevi che vi sto dicendo, lo stimolo di corrente l'ho messo soltanto nel Soma, è lì che si genera lo spike e poi succede quello che deve succedere. Qui c'è sempre uno spike, si vede che parte prima il nero, poi il rosso, poi il blu e poi il verde, suggerendo che c'è una propagazione, c'è una propagazione spaziale. Quando l'assone inizia ad essere sufficientemente lungo, in questo caso è a 500 micrometri, tenete conto che gli assoni che hanno il record di lunghezza, sto pensando a un neurone talamo corticale che è dell'ordine di diversi millimetri, però nell'uomo in teoria dei neuroni che hanno origine nel tratto piramidale, Nello spinal cord sono almeno mezzo metro, un metro, qualcosa del genere. Quindi è vero che quelle fibre sono mielinate, quindi la propagazione è diversa perché è saltatoria, però vedete che già a qualche centinaio di micrometri si apprezza un ritardo di propagazione di qualche millisecondo. In teoria, per esempio, un possibile esercizio potrebbe essere di ripetere questa simulazione per diversi valori o della lunghezza dell'assone oppure della posizione degli elettoridi che registrano il potenziale d'azione nei dendriti e calcolare la velocità di propagazione. Sapete perché la definite voi lo spazio, la distanza fra il Soma e il dendrite, immagino di fare un dendrite molto lungo così che possiate avere diversi valori di ritardo spazialmente ben separati. Se io questo lo metto a un valore molto elevato, non so perché qui è diventato così lungo, a quasi 2 mm, qui adesso è diventato quasi da questo, ok, sarà 5 millisecondi di ritardo, che è notevole. Se io faccio 1990, supponete 2000 micrometri diviso 5 millisecondi o 400 micrometri al secondo e se moltiplico per 1000 sono in millimetri, no? Dunque, questi sono micrometri, quindi un micrometro è 0.001 millisecondi, sono 2.000 micrometri diviso 5 millisecondi, quindi sono 2 millimetri al millisecondo, perché lo voglio in metri al secondo, ok, 2 mm al millisecondo, milli e milli si cancellano, vuol dire 0,4 metri al secondo, che è lento, comunque è abbastanza lento. Non mi ricordo se questo è nel... Chi c'era l'anno scorso quando ho fatto il talk al caffè Scienza, Elmonds misurava, sì era Elmonds che misurava la velocità di propagazione dei potenziali d'azione nella rana, in effetti lì c'era anche un tempo di conduzione del muscolo e si era scocciato perché era lento ed era anche nell'uomo così lento e mezzo metro al secondo è abbastanza lento, paragonato con le velocità con cui i segnali si propagano in un dispositivo elettronico artificiale. Però quello che potreste provare a fare è vedere se questo valore che è uscito fuori così a spanne prendendo a occhio questa distanza, farlo bene cioè fare la peak detection, trovare i picchi trovare qual è la coordinata temporale per cui ci sono i picchi e plottarla in un grafico in cui c'è la distanza e nell'altro c'è il tempo dovrebbe i punti di spike diversi dovrebbero allinearsi sulla stessa retta e la pendenza di questa retta dovrebbe essere la velocità quindi sto suggerendo di fare un grafico delta delta l in funzione di delta t dove delta t è in ritardo delta l è quello che imponete e visto che la velocità se è uniforme dovrebbe essere la stessa per quali che sia delta l dovrebbe sempre venirvi fuori 0,4 metri al secondo anche se lo vedete per quindi se lo purtroppo qui non è la libreria che ho usato per plottare, non mi permette di vedere questi punti, dovrei cambiarla con un'altra, con plotly se mi ricordo bene, però questo potrebbe essere un altro esercizio, di nuovo fare lo stesso esercizio scrivendo voi lo stesso codice farebbe caldo, sarebbe tosto farlo, Qui praticamente in pochi secondi avete la simulazione che vi serve. Un'altra cosa che vi è dimostrata qua e spero vogliate giocarci, qui non vi chiedo di fare particolari cose, ho messo una sinapsi a una certa distanza, alla distanza finale del dendrite, quanto più il dendrite è lungo, quindi qui è tornato il cavo passivo, Quanto più il dendrite è lungo, tanto più lontana è la sinapsi, tanto più è l'attenuazione elettrotonica e più evidente. Gli altri slider mi permettono di cambiare l'ampiezza della sinapsi, il numero di volte che è attivata, il numero di impulsi, se uno, due, questi dovrebbero essere dei potenziali eccitatori post-sinaptici registrati al punto dove sono emessi, quindi al punto distale. e in nero c'è il potenziale del Soma e vedete che un bellissimo, fortissimo IPSP, dendrite, distale a 650 micrometri, si propaga fino al Soma, però al Soma lo depolarizza di qualche, forse di 5-10 millivolt. Se magari ho più impulsi c'è una sommazione temporale, vedete che la traccia nera sta come il mio conto in banca, non so se ve l'ho raccontato la storia del conto in banca che aumenta mese in mese, qui è un po' diverso perché avete anche il decay, però Tantea a un certo punto satura, non riesco a emettere uno spike. Quindi questa sinapsi a 600 micrometri non farà mai sparare il neurone, a meno che non cambi la frequenza di attivazione, ma è già al massimo, 200 Hz. 200 attivazioni al secondo che parecchio, addirittura per una sinapsi non potrebbe farlo, o forse aumentando la dismisura l'ampiezza. Aumentando la dismisura l'ampiezza farebbe sparare il neurone. Però dopo un po', dato che è una sinapsi basata sulle conduttanze, vagamente vi ricorderete che vi ho detto che esiste un fenomeno di saturazione, quindi quando i neurotrasmettitori, no, i recettori iposinaptici sono completamente occupati, Se anche io aumento ancora di più, quindi questo sto cambiando, allora non la conduttanza post-sinaptica che non dovrebbe avere saturazione. Qui devo pensarci. Vedete, questo è uno svantaggio perché il tipo di sinapsi, io qui facendovi vedere il codice, mi sono fidato del meccanismo che Neuron mi mette a disposizione. Non l'ho fatto io e quindi devo fare un po' di attenzione. Quindi è questa cosa qua. Ho messo un alpha function al 90% della distanza del dendrite, quindi è una sinapsi eccitatore con il potenziale di inversione che è 0, come AMPA. Le costanti tau1 e tau2 hanno a che fare con rise time e decay time, non hanno importanza, ma qui non so esattamente come l'ha messa nel secondo membro di quell'equazione. Addirittura poi qui è con l'equazione del cavo, quindi qui non so perché saturi. Potrebbe essere che satura perché... Perché satura? forse perché non è un'iniezione di corrente, è un'iniezione di conduttanza, ed è un cavo, fosse un singolo compartimento forse sarebbe diverso, se io rendo localmente la membrana distale molto liqui, perché ho un sacco di conduttanza, potrebbe essere che dal punto di vista elettrico la corrente ha una minore capacità di andare in questo percorso che ha più alta resistenza e tende ad andare verso o l'altra estremità oppure tende ad andare qui, a dispersi qui dove la membrana è molto più liquida. Però questa potrebbe non essere la spiegazione giusta. Io non dovrei avere in un modello l'imbarazzo di non capire perché qualche cosa sta avvenendo, Però qui io lo vedo che aumentando l'ampiezza degli PSP, lo vedo già in rosso qui, nel dendrite non cambia. Allora mi viene in mente di pensare, ok, faccio... Sì, grazie. Quindi quello che ho fatto è mettere la lunghezza dell'endendrite piccola, quindi ho creato elettrotonicamente tutto e collassato come se fosse in un compartimento solo. E qui addirittura adesso vedo che ogni singola, ogni singolo IPSP fa sparare il neurone, quindi l'ampiezza è troppo elevata. ma anche così è elevatissima. Se cambio la frequenza, niente, qui l'ampiezza è molto elevata, quindi in teoria dovrei fare, dovrei toccare, non è impossibile, è solo noioso, dovrei cambiare qua e dire al minimo voglio andare, scusate, qui voglio farlo ancora più, voglio poter scendere ancora di più nell'ampiezza. quindi devo devo cambiare qualcosa e qui non gli piace perché non ti piace aha no perché non ti piace non ti piace undo non gli piace il punto sì, non gli piaceva il punto chissà perché, ma io voglio poter fare 0.0, no? se no non è un float, ok? ma 0.0 non gli piace che caspita però vabbè, google fai quello che vuoi io volevo prendere lo step e metterlo molto più piccolo in modo tale che quando lo inizio ad aumentare posso aumentare un pochettino dovrei vedere una gobbettina però non credo di vedere la saturazione oppure no perché ho gli spike se non voglio vedere gli spike devo ammazzare Wang Guzaki sia nei dendriti che nel Soma no, perdon, solo no, no, l'ammazzo dappertutto ok, c'è solo nel Soma e quindi qui in teoria qui non dovrebbe essere ah, perdono, scusate sono stupio certo, certo è una sinapsi AMPA una sinapsi basata sulle condottanze e quindi questo non è gran che vai quindi la corrente sinaptica ha G bar poi ci sarà una qualche varia di stato che si chiama come si chiama e ha questo è zero, quindi quanto più quella conduttanza è elevata, tanto più V inizia a diventare vicino a zero, a livello distale, quindi non importa al Soma, magari il Soma lo carica un pochino, ma nel dendrite distale è facile che lui, se questo valore è molto molto elevato, qui esploda, e solo che se esplode va al massimo ad avvicinarsi a zero, poi questo valore qua inizia a diventare sempre più piccolo, è per questo che satura, non satura i recettori, mi avvicino al potenziale di inversione di quella corrente, quindi di più di quello non posso fare. Questo termine inizia a diventare molto piccolo perché arrivo vicino al potenziale, è lo stesso motivo per cui gli spike non possono oltrepassare il potenziale di inversione del sodio, tipicamente non lo fanno, si tengono sui 20 millivolt, ma se potessero più di 50 millivolt o quello che è il potenziale di inversione del sodio non potrebbero fare. E qui lo stesso motivo. una sinapsi una sinapsi distale può o meno far sparare un il soma a una certa distanza si sa che c'è un'attenuazione notevole elettrotonica e che a un certo punto la sinapsi non può non può depolarizzare il soma arbitrariamente in particolare per quel però ricostruire questa cosa nelle vostre in un settings vostro potrebbe essere potrebbe essere di interesse non mi ricordo adesso finiamo abbiamo finito volevo solo vedere quale fosse il l'altro l'altro notebook che avevo preparato perché non me lo ricordo più ok era questo qui sì solo perché allora mi può però ripetere qual era l'inizio della domanda cos'è che vp di wang buzzaki si si li applica tutti e 51 quello che mi è possibile fare e eventualmente cambiare il cambiare il valore delle delle conduttanze con un ciclo foro immaginate che Questo Wang Guzaki, adesso finisco e facciamo la prossima volta, questo Wang Guzaki contiene al suo interno sia il sodio che il potassio e quindi ha un G sodio e G potassio. Voi potreste cambiare elemento per elemento, segmento per segmento, sezione per sezione, ciascuno di questi 51 cosi, in modo tale che potreste avere un gradiente o potreste mettere a zero una di queste due quantità. Quindi il meccanismo c'è dappertutto, però il valore numerico, che di fatto se io questi entrambi, questi qui li metto a zero, è come se non c'è il meccanismo. Neuron fatica un po', perché le equazioni le risolve comunque, ma al momento di generare la corrente genera zero, non ha alcun impatto sul comportamento elettrico del neurone. Quindi con quello stesso ciclo for avrei potuto cambiare le singole conduttanze e quindi rendere l'assone eterogeneo. Per esempio una cosa che potreste provare a fare, posto di riuscire a capire come quel ciclo for si può Google, adesso non vi rompo le scatole ma basta Google, Quindi in questo ciclo 4, come faccio ad avere la coordinata? Perché se io riuscissi ad avere la coordinata, perlomeno la coordinata interna numerica fra 0 e 1, potrei per esempio fare che con una qualche funzione matematica che vi lascio il compito di derivare, ma probabilmente qualcosa di simile al resto della divisione intera, potreste fare che qui avete GNA e GK a un certo valore, qui ce l'avete a zero, qui ce l'avete a zero, qui è grande, qui è zero, qui è zero, qui è grande di nuovo, qui è zero, qui è grande di nuovo, la distribuzione delle conduttanze in punti diversi della storia semplicemente con quel ciclo foro la scocciatura che non so adesso sulle piedi come si fa è che qui qual è seg vediamo se solo per provare se dico seg forse x potrebbe essere x questo potrebbe essere un valore numerico c'è da mettere dei print e di vedere che cosa succede non lo faccio adesso questo sarebbe l'unico problema da risolvere come faccio ad avere la coordinata spaziale in modo tale che io posso dire se questo è il resto della divisione intera però dovete usare credo numpy quindi np.mod nseg quello che è 10 micrometri lui lo fa soltanto quando questo è uguale a 0 o forse dovreste fare minore uguale di un numero molto piccolo perché non credo che sarà perfettamente uguale a 0 questo resto della visione intera con questa cosa qua quindi if questo bla bla allora seg g bar g n bar uguale a 0 uguale a qualcosa e poi else la stessa cosa g n bar uguale a 0 così fareste la conduzione saltatoria Non è la stessa cosa perché dovreste forse togliere il leak, perché quando c'è la mielina, lì non c'è più, è tutto tappato, non c'è più leak. E by the way, mi avete fatto venire in mente che l'anno scorso, un paio di anni fa, avevo il problema di dover fare un assone mielinizzato, e sembra un metodo furbo questo per farlo, senza cose complicate. Se volete provateci, non è obbligatorio fare questi giochi. Vi faccio vedere l'ultimo notebook in cui avevo una sequenza, un insieme di tante conduttanze e vi faccio vedere cosa succede. L'ho chiamato The Zoo of Iron Channels. Quindi che succede se metti un pochino di IA e poi metti il sodio persistente ma non metti la corrente IH oppure metti l'IH ma non metti le altre due, come cambia l'attività spiking? Ce l'avete se potete giocate. Dalla settimana prossima parliamo invece di modelli più ridotti che permettono, vedrete, di derivare delle considerazioni molto interessanti a livello di rete. Questo potete fare una rete di, e Markram e altri hanno fatto reti di centinaia di migliaia di neuroni, ma avete un sistema che è complicato tanto quanto il, o comunque magari non è tanto quanto il sistema biologico, ma è enormemente complicato, con un numero enorme di parametri liberi e un numero enorme di variabili, a parte che impiega un tempo. Google Collab, scordatevi che possa fare una roba del genere. Sapete eventualmente di trovarmi se avete domande. Grazie e ci vediamo la prossima settimana.